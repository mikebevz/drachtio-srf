/// <reference types="node" />
/**
 * Class representing a SIP Dialog.
 *
 * Note that instances of this class are not created directly by your code;
 * rather they are returned from the {@link Srf#createUAC}, {@link Srf#createUAC}, and {@link Srf#createB2BUA}
 * @class
 * @extends {Emitter}
 * @type {Dialog}
 */
export class Dialog extends Emitter {
    /**
     * Constructor that is called internally by Srf when generating a Dialog instance.
     * @param {Object} srf - Srf instance that created this dialog
     * @param {'uac' | 'uas'} type - type of SIP dialog: 'uac', or 'uas'
     * @param {Object} opts
     * @param {Request} opts.req
     * @param {Response} opts.res
     * @param {Request|Response} [opts.sent]
     * @constructor
     */
    constructor(srf: any, type: 'uac' | 'uas', opts: {
        req: Request;
        res: Response;
        sent?: Request | Response;
    });
    /** @type {Object} */
    srf: any;
    /** @type {'uac' | 'uas'} */
    type: 'uac' | 'uas';
    /** @type {Request} */
    req: Request;
    /** @type {Response} */
    res: Response;
    /** @type {DrachtioAgent} */
    agent: DrachtioAgent;
    onHold: any;
    connected: any;
    queuedRequests: any;
    _queueRequests: any;
    _reinvitesInProgress: any;
    /**
     * sip properties that uniquely identify this Dialog
     * @type {Object}
     * @property {string} callId - SIP Call-ID
     * @property {string} localTag - tag generated by local side of the Dialog
     * @property {string} remoteTag  - tag generated by the remote side of the Dialog
     */
    sip: any;
    /**
     * local side of the Dialog
     * @type {Object}
     * @property {String} uri - sip
     * @property {String} sdp - session description protocol
     */
    local: any;
    /**
     * remote side of the Dialog
     * @type {Object}
     * @property {String} uri - sip
     * @property {String} sdp - session description protocol
     */
    remote: any;
    subscriptions: any;
    /**
     * @return {string}
     */
    get id(): string;
    get dialogType(): string;
    get subscribeEvent(): string;
    get socket(): import("net").Socket | import("tls").TLSSocket;
    set stateEmitter(arg: any);
    _emitter: any;
    _state: any;
    set queueRequests(arg: any);
    toJSON(): any;
    toString(): any;
    getCountOfSubscriptions(): any;
    addSubscription(req: any): any;
    removeSubscription(uri: any, event: any): any;
    /**
     * destroy the sip dialog by generating a BYE request (in the case of INVITE dialog),
     * or NOTIFY (in the case of SUBSCRIBE)
     * @param {Object} [opts] configuration options
     * @param {Object} [opts.headers] SIP headers to add to the outgoing BYE or NOTIFY
     * @param  {function} [callback] if provided, callback with signature <code>(err, msg)</code>
     * that provides the BYE or NOTIFY message that was sent to terminate the dialog
     * @return {Promise|Dialog} if no callback is supplied, otherwise a reference to the Dialog
     */
    destroy(opts?: {
        headers?: any;
    }, callback?: Function): Promise<any> | Dialog;
    /**
     * modify the dialog session by changing attributes of the media connection
     * @param  {string} sdp - 'hold', 'unhold', or a session description protocol
     * @param  {function} [callback] - callback invoked with signature <code>(err)</code> when operation has completed
     * @return {Promise|Dialog} if no callback is supplied, otherwise the function returns a reference to the Dialog
     */
    modify(sdp: string, opts: any, callback?: Function): Promise<any> | Dialog;
    _promiseTxnInProgress: any;
    /**
     * send a request within a dialog.
     * Note that you may also call <code>request.info(..)</code> as a shortcut
     * to send an INFO message, <code>request.notify(..)</code>
     * to send a NOTIFY, etc..
     * @param {Object} [opts]
     * @param {string} opts.method - SIP method to use for the request
     * @param {Object} [opts.headers] - SIP headers to apply to the request
     * @param {string} [opts.body] - body of the SIP request
     * @param {Object} [opts.auth] - auth
     * @param {boolean} [opts.noAck]
     * @param {function} [callback]  - callback invoked with signature <code>(err, req)</code>
     * when operation has completed
     * @return {Promise<Dialog>|Dialog} if no callback is supplied a Promise that resolves to the response received,
     * otherwise the function returns a reference to the Dialog
     */
    request(opts?: {
        method: string;
        headers?: any;
        body?: string;
        auth?: any;
        noAck?: boolean;
    }, callback?: Function): Promise<Dialog> | Dialog;
    /**
     *
     * @param {Request} req
     * @param {Response} res
     * @param {Function|null} next
     * @returns
     */
    handle(req: Request, res: Response, next?: Function | null): void;
    /**
     *
     * @param {Object} opts
     * @param {VoidFunction} cb
     */
    invite(opts: any, cb: VoidFunction): Dialog | Promise<Dialog>;
    /**
     *
     * @param {Object} opts
     * @param {VoidFunction} cb
     */
    register(opts: any, cb: VoidFunction): Dialog | Promise<Dialog>;
}
import Emitter = require("events");
import Request = require("./request");
import Response = require("./response");
import DrachtioAgent = require("./drachtio-agent");
